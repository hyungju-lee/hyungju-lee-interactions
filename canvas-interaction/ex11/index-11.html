<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>A Simple Canvas Example</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;900&display=swap" rel="stylesheet">
    <style>
        html {font-family: 'Noto Sans KR', sans-serif;}
        body { background-color: #ddd }
        #canvas { margin: 10px; padding: 10px; background-color: #fff; border: thin inset #aaa; }
    </style>
</head>
<body>
<canvas id="canvas" width="600" height="300">
    Canvas not supported
</canvas>
<div>
    <h1>간단한 수학 입문</h1>
    <p>
        캔버스를 이용해 재미있는 애플리케이션을 만들려면 수학에 대한 기본 개면, 특히 대수 방정식, 삼각법, 백터 등을 이해해야 한다. <br>
        그리고 이런 기본 지식이 있어야만 비디오 게임과 같이 복잡한 애플리케이션을 만들 때 측정 단위로부터 방정식을 이끌 수 있다. <br>
        여러분이 기본 대수학과 삼각법을 알고 있고 픽셀/초와 밀리초/프레임을 픽셀/프레임으로 표현할 수 있다면 이 절을 쉽게 이해하고 지나갈 수 있을 것이다. <br>
        하지만 그렇지 않다면 이 책 나머지 부분을 위해 이 절에서 많은 시간을 할애하기를 권한다. <br>
        <br>
        이 절에서는 대수 방정식과 삼각법을 살펴본 다음, 측정 단위로부터 방정식을 이끌어내는 방법과 벡터에 대해 자세히 살펴보자.
    </p>
    <h2>대수 방정식 풀이</h2>
    <p>
        (10x + 5) * 2 = 110과 같은 대수방정식을 풀 때에는 다음과 같은 방법을 사용한다. <br>
        어떤 방법을 사용해도 방정식의 결과는 달라지지 않는다.
    </p>
    <ul>
        <li>양변에 실수를 더한다.</li>
        <li>양변에서 실수를 뺀다.</li>
        <li>양변에 실수를 곱한다.</li>
        <li>양변을 실수로 나눈다.</li>
        <li>양변이나 한 변을 1로 나누거나 곱한다.</li>
    </ul>
    <p>
        위에서 언급한 (10x + 5) * 2 = 110을 예로 들어보자. <br>
        먼저, 양변을 2로 나눠 방정식을 풀 수 있다. <br>
        즉, 방정식은 10x + 5 = 55로 나타낼 수 있다. <br>
        그리고 양변에서 5를 빼면, 10x = 50 이라는 방정식을 얻게 된다. <br>
        마지막으로 양변을 10으로 나누면 방정식은 x = 5로 나타낼 수 있고 x 값을 얻게 된다.
    </p>
    <p>
        물론 위에서 언급한 방법 가운데 마지막 방법은 이상하게 생각될 것이다. <br>
        방정식 양변이나 한 변을 1로 나누거나 곱하는 이유는 무엇일까? <br>
        이 질문에 대한 답변은 측정 단위로부터 방정식을 도출하는 방법을 소개한 ('측정 단위에서 방정식 산출하기')에서 간단한 규칙을 이용해
        알아볼 것이다.
    </p>
    <h2>삼각법</h2>
    <p>
        캔버스를 가장 쉽게 사용하려고 해도 삼각법에 대한 기본적인 개념이 필요하다. <br>
        참고로 다음 장에서는 사인과 코사인을 사용해 다각형을 그리는 방법을 소개할 것이다. <br>
        이 절에서는 직각 삼각형을 살펴보며 각도에 대해 간략하게 배워보자.
    </p>
    <p>
        각도를 다루는 캔버스 API의 모든 함수에서는 각도를 <strong>라디안</strong>으로 명시해야 한다. <br>
        그리고 자바스크립트 함수인 <strong>Math.sin()</strong>, <strong>Math.cos()</strong>, <strong>Math.tan()</strong>에서도 각도를 라디안으로 명시해야 한다.
        <br>
        대부분 각도라 하면 도(degree)를 생각하므로 도를 라디안으로 전환하는 방법을 알아야 한다.
    </p>
    <p>
        180도는 π 라디안이다. <br>
        도를 라디안으로 전환하려면 다음 방정식처럼 지금 언급한 관계를 대수 방정식으로 표현해야 한다.
    </p>
    <div><img src="explain01.jpg" alt=""></div>
    <h2>사인, 코사인, 탄젠트</h2>
    <p>
        캔버스를 효율적으로 사용하려면 사인, 코사인, 탄젠트에 대한 기본 개념을 이해해야 한다. <br>
        삼각함수는 아주 간단히 표현해서 다음과 같다.
    </p>
    <div><img src="explain02.jpg" alt=""></div>
    <div><img src="explain03.jpg" alt=""></div>
    <h2>벡터</h2>
    <p>
        이 책에서 사용하는 벡터는 2차원 벡터로 방향과 크기에 대한 값을 가지고 있다. <br>
        방향과 크기 등 두 값을 사용해 힘과 운동 등과 같은 모든 물리적인 특성을 표현할 수 있다.
    </p>
    <p>
        <strong>충돌감지</strong> 장에서 백터에 대한 자세한 사용법을 소개할 것이므로 이 절에서는 벡터 수학에 대한 기본 원칙을 배워보자. <br>
        만약 충돌감지를 구현하는 것에 흥미가 없다면 이 절을 건너뛰어도 좋다. <br>
        <strong>충돌감지</strong> 장의 마지막 부분에서는 아래 그림처럼 다각형이 다른 다각형이 부딪혀 반사할 때 두 다각형 사이에 발생하는 충돌에 반응하는
        방법을 살펴볼 예정이다. <br>
        <br>
        아래 그림은 위에 있는 다각형이 아래에 있는 다각형을 향해 이동하고 있는 그림으로 두 다각형은 충돌하기 직전이며, <br>
        위에 있는 다각형이 들어오는 속도와 나가는 속도를 벡터로 표시했다. <br>
        그리고 위에서 이동하는 다각형과 부딪힐 예정인 아래에 있는 다각형의 모서리를 <strong>에지 벡터(edge vector)</strong>로 알려진 벡터로
        표시하고 있다.
    </p>
    <div><img src="explain04.jpg" alt=""></div>
    <p>
        혹시라도 들어오는 속도와 아래에 있는 다각형의 모서리에 대한 두 점을 알고 있을 때 나가는 속도를 계산하는 방법이 궁금하다면 <br>
        <strong>충돌감지</strong>장으로 넘어가서 확인해보자. <br>
        그러나 기본 백터에 익숙하지 않다면 이 절을 자세하게 살펴보라.
    </p>
    <h2>벡터 크기</h2>
    <p>
        2차원 벡터는 방향과 크기 등 두 가지 양으로 이뤄지지만, 벡터를 이용해 다른 벡터를 구할 수 있다. <br>
        고등학교 때 수학 시간에 배운 기억을 회상하면서 아래 그림에서 보여주는 것처럼 피타고라스의 정리를 이용해 벡터의 크기를 계산해보자.
    </p>
    <div><img src="explain05.jpg" alt=""></div>
    <p>
        피타고라스의 정리에서는 직각 삼각형의 빗면은 다른 두 변에 대한 제곱의 합에 루트를 씌운 값과 같다고 명시돼있다. <br>
        이 말은 위 그림을 보면 쉽게 이해갈 것이다. <br>
        이 말을 자바스크립트 코드로 나타내면 다음과 같다.
    </p>
    <pre>
        <code>
            var vectorMagnitude = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
        </code>
    </pre>
    <p>
        위 자바스크립트 고드에서는 vector라는 이름의 변수에 의해 참조된 벡터의 크기를 계산하는 방법을 보여주고 있다. <br>
        지금까지 벡터의 크기를 계산하는 방법을 배웠다. <br>
        이제 벡터의 다른 양인 방향을 계산하는 방법을 살펴보자.
    </p>
    <h2>단위 벡터</h2>
    <p>
        백터를 계산하려면 <strong>단위 벡터</strong>가 필요하다. <br>
        아래 그림에서는 방향만 알려주는 단위 벡터를 보여주고 있다.
    </p>
    <div><img src="explain06.jpg" alt=""></div>
    <p>
        단위 벡터란 이름은 벡터의 크기가 항상 1이기 때문에 붙여졌다. <br>
        임의 크기를 가진 벡터가 주어질 때 단위 벡터를 계산하려면, 벡터에서 크기를 제거하고 방향만 남겨두어야 한다. <br>
        다음은 단위 벡터를 계산하는 방법을 자바스크립트 코드로 나타낸 것이다.
    </p>
    <pre>
        <code>
            var vectorMagnitude = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2)),
                unitVector = new Vector();

            unitVector.x = vector.x / vectorMagnitude;
            unitVector.y = vector.y / vectorMagnitude;
        </code>
    </pre>
    <p>
        위 코드를 살펴보면 앞 절에서 계산한 것처럼 먼저 vector란 이름의 백터를 이용해 벡터의 크기를 계산하고 있다. <br>
        그리고 새로운 벡터를 생성한 다음 원래 벡터의 X와 Y에 해당하는 값을 벡터의 크기로 나눈 값을 새롭게 생성한 벡터의 X 및 Y에 설정하고 있다. <br>
        이 부분은 <strong>충돌감지</strong> 장에서 Vector 오브젝트에 대한 코드를 참고하자. <br>
        <br>
        지금까지 2차원 벡터의 두 가지 양을 계산하는 방법을 알아봤다. <br>
        다음 절에서는 벡터를 결합하는 방법을 소개할 것이다.
    </p>
    <h2>벡터 덧셈과 뺄셈</h2>
    <p>
        벡터의 덧셈과 뺄셈 연산은 매우 유용하게 사용된다. <br>
        여러분의 몸에 작용하는 힘이 두 가지가 있다고 가정해보자. <br>
        두 힘을 나타내는 두 벡터를 더해 하나의 힘으로 계산할 수 있다. <br>
        마찬가지로 한 위치 벡터에서 다른 위치 벡터를 빼면 두 벡터 사이의 모서리를 산출할 수 있따.
    </p>
    <div><img src="explain07.jpg" alt=""></div>
    <p>
        벡터의 합은 단순히 벡터의 요소를 더하면 되므로 계산하는 방법은 간단하다. <br>
        다음은 이 방법을 코드로 나타낸 것이다.
    </p>
    <pre>
        <code>
            var vectorSum = new Vector();

            vectorSum.x = vectorOne.x + vectorTwo.x;
            vectorSum.y = vectorOne.y + vectorTwo.y;
        </code>
    </pre>
    <p>
        그리고 벡터의 차를 구하는 방법도 벡터의 합과 같이 간단하다. <br>
        다음 코드와 같이 벡터의 요소를 빼면 벡터의 차를 구할 수 있다. <br>
        아래 그림에서는 벡터의 차를 구해 세번재 벡터를 산출하는 방법으 ㄹ보여주고 있다. <br>
        이때, <strong>세번재 벡터의 방향은 두 벡터 사이의 모서리와 일치한다.</strong> <br>
        아래 그림에서 벡터 A-B와 벡터 B-A는 서로 평행하며 이 벡터들은 벡터 A와 벡터 B 사이의 <strong>엣지 벡터</strong>와도 평행하다.
    </p>
    <div><img src="explain08.jpg" alt=""></div>
    <h2>두 벡터의 내적</h2>
    <p>
        두 벡터의 내적을 구하려면 벡터끼리의 요소를 곱한 다음 그 값을 더해야 한다. <br>
        다음 코드는 2차원 벡터로 내적을 산출하는 방법을 나타낸 것이다.
    </p>
    <pre>
        <code>
            var dotProduct = vectorOne.x * vectorTwo.x + vectorOne.y * vectorTwo.y;
        </code>
    </pre>
    <p>
        위 코드에서 알 수 있듯이 두 벡터 사이의 내적을 산출하는 방법은 어렵지 않다. <br>
        그러나 내적의 의미를 이해하기는 생각만큼 쉽지 않다.
    </p>
    <ol>
        <li>먼저, 두 벡터의 덧셈이나 뺄셈의 결과와 다르게 내적은 벡터가 아니라는 점에 주목하자.</li>
        <li>그리고 벡터 내적의 결과를 <strong>스칼라(scalar)</strong>라고 부른다.</li>
        <li>쉽게 말하면 단순한 숫자를 뜻한다.</li>
        <li>이 숫자의 의미를 이해하기 위해 아래 그림을 보자.</li>
    </ol>
    <div><img src="explain09.jpg" alt=""></div>
    <ol>
        <li>위 그림에서 두 내적은 528이다.</li>
        <li>여기서 이 숫자가 양수이지만 크기가 아니라는 점을 중요하게 생각해야 한다.</li>
        <li>그리고 0보다 큰 수는 두 벡터가 거의 같은 방향이라는 의미다.</li>
    </ol>
    <div><img src="explain10.jpg" alt=""></div>
    <ol>
        <li>위 그림에서 두 벡터의 내적은 -528이다.</li>
        <li>이 값은 0보다 작으므로 두 벡터는 거의 다른 방향을 향하고 있다고 추측할 수 있다.</li>
    </ol>
    <p>
        두 벡터가 같은 방향인지 아닌지는 물체 사이에 충돌이 발생할 때 반응하는 방법에 대단히 큰 영향을 미친다. <br>
        움직이는 물체가 정지된 물체에 충돌할 때 충돌 후 반사하려면, 움직이는 물체가 정지된 물체의 중심을 향하는 것이 아니라 정지된 물체로부터 멀어져야 한다. <br>
        두 벡터의 내적을 사용하면 이런 상황을 정확하게 판단할 수 있다. <br>
        자세한 내용은 <strong>충돌감지</strong> 장에서 살펴볼 예정이다. <br>
        <br>
        지금까지 배운 벡터에 관한 내용은 충돌 감지를 구현할 때 필요하다. <br>
        다음 절은 수학 입문의 마지막으로 측정 단위로부터 방정식을 산출하는 방법을 살펴볼 것이다.
    </p>
    <h2>측정 단위에서 방정식 산출하기</h2>
    <p>
        물체가 움직이는 속도에 대한 비율은 애니메이션의 프레임 비율에 따라 <strong>변경되지 않으므로</strong> 애니메이션 속의 움직임은 시간에 의존적이다. <br>
        이 내용은 5장에서 자세히 다룰 예정이다. <br>
        시간 의존적인 움직임은 사용자가 여러 명인 게임에서 매우 중요하다. <br>
        성능이 좋은 컴퓨터를 가진 사용자가 다른 사용자보다 게임을 빠르게 진행하는 것을 원하는 사람은 없기 때문이다.
    </p>
    <p>
        시간 의존적인 움직임을 구현하기 위해 이 책에서는 속도를 <strong>픽셀/초</strong>로 명시하고 있다. <br>
        현재 애니메이션 프레임에서 물체가 움직이는 데 필요한 픽셀을 산출하려면 두 가지 정보를 알아야 한다.
    </p>
    <ol>
        <li>첫번째 정보는 <strong>픽셀/초</strong>로 표시한 물체의 속도</li>
        <li>두번째 정보는 <strong>밀리초/프레임</strong>으로 표시한 애니메이션의 현재 프레임률</li>
    </ol>
    <p>
        여기서 필요한 값은 물체를 움직이기 위한 <strong>픽셀/프레임</strong>이다. <br>
        <strong>픽셀/프레임</strong>을 산출하려면 아래 방정식처럼 우변에는 밀리초/프레임(현재 프레임률)과 픽셀/초(물체의 속도) 그리고 좌변에는 픽셀/프레임을 가지고
        있는 방정식을 산출해야 한다.
    </p>
    <div><img src="explain11.jpg" alt=""></div>
    <p>
        위 부등식에서 X는 밀리초/프레임으로 표시한 애니메이션의 프레임률을 나타내고 있으며, <br>
        Y는 픽셀/초로 표시한 물체의 속도를 나타내고 있다. <br>
        <strong>하지만 부등식에서 보이는 대로 단순히 밀리초/프레임을 픽셀/초에 곱할 수 없다.</strong> <br>
        왜냐하면, 단순히 곱하면 <strong>밀리초-픽셀/프레임-초란 무의미한 결과</strong>를 가져오기 때문이다. <br>
        그렇다면 어떻게 해야할까?
    </p>
    <p>
        대수 방정식을 푸는 방법을 소개했던 <strong>대수방정식 풀이</strong>에서 배웠던 마지막 규칙을 생각해보자. <br>
        마지막 규칙은 방정식 양변이나 한쪽 변에 1을 곱하거나 나눌 수 있다는 내용이었다. <br>
        이 규칙과 1초가 1000ms와 같고 1초/1000ms가 1과 같다는 내용에 따라 아래와 같이 1초/1000ms를 방정식의 우변에 곱할 수 있다.
    </p>
    <div><img src="explain12.jpg" alt=""></div>
    <p>
        그러면 위 식에서 분자와 분모를 소거해보자. <br>
        분수의 분자에 대한 측정 단위로 다른 분수의 분모에 대한 같은 측정 단위를 소거할 수 있으므로 아래와 같이 측정단위를 소거할 수 있다.
    </p>
    <div><img src="explain13.jpg" alt=""></div>
    <div><img src="explain14.jpg" alt=""></div>
    <div><img src="explain15.jpg" alt=""></div>
    <p>
        지금과 같이 방정식을 산출하면 간단한 숫자를 방정식에 대입해 방정식이 정상적으로 산출됐는지 확인해야 한다. <br>
        물체가 100px/초로 이동중이고 프레임률이 500ms/프레임이라고 가정해보자. <br>
        방정식을 확인할 필요도 없이 물체가 0.5초마다 50px씩 이동하는 것을 쉽게 확인할 수 있다.
    </p>
    <p>
        위 방정식에 이 숫자들을 대입하면, 방정식은 500X100/1000이 되므로 결과는 50이다. <br>
        따라서 속도와 프레임률을 위한 적당한 방정식을 사용하고 있다고 볼 수 있다. <br>
        <br>
        보통 다음과 같은 단계를 통해 측정 단위가 있는 변수로부터 방정식을 도출할 수 있다.
    </p>
    <ol>
        <li>좌변에 결과가 있고 우변에 변수를 넣은 부등식으로 시작한다.</li>
        <li>방정식 양변에 측정 단위가 주어지면 방정식 좌변에 있는 측정 단위를 산출할 수 있게 방정식 우변의 측정 단위를 소거할 수 있는 1과 같은 한 개 이상의 분수를 방정식 우변에 곱한다.</li>
        <li>방정식 우변에 있는 측정 단위를 소거한다.</li>
        <li>방정식 우변에 있는 분수를 곱한다.</li>
        <li>결과를 쉽게 확인할 수 있도록 간단한 값을 방정식에 대입해 방정식이 기대한 값을 도출하는지 확인한다.</li>
    </ol>
</div>
<script>
    var canvas = document.getElementById('canvas'),
        context = canvas.getContext('2d');

    context.font = '38pt Arial';
    context.fillStyle = 'cornflowerblue';
    context.strokeStyle = 'blue';

    context.fillText('Hello Canvas', canvas.width / 2 - 150, canvas.height / 2 + 15);
    context.strokeText('Hello Canvas', canvas.width / 2 - 150, canvas.height / 2 + 15);
</script>
</body>
</html>